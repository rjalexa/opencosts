Here is a clean, API‑only Python implementation that does exactly what you outlined:

starts from a list of substrings (e.g., “Gemini 2.5”, “Sonnet 4”, …)

finds all matching models (case‑insensitive)

filters out free variants

returns, for each match: Model name, Model URL, OpenRouter model ID

then fetches the providers for each model and extracts, per provider: provider name, context length, price/input token, price/output token

latency/throughput columns are included but set to None unless OpenRouter later adds them to the endpoints API (see note below).

Sources:
– List available models (/api/v1/models) includes canonical_slug used to build model URLs. 
OpenRouter

– List endpoints for a model (/api/v1/models/:author/:slug/endpoints) exposes provider_name, context_length, and pricing.prompt/completion. (No latency/throughput fields documented as of 26 Jul 2025.) 
OpenRouter

– “Free” variants use a :free suffix in the slug/ID (e.g., deepseek/deepseek-r1:free). 
OpenRouter

Python (requests, standard lib)
python
Copy
Edit
from __future__ import annotations

import concurrent.futures as cf
from dataclasses import dataclass
from typing import Iterable, List, Dict, Any
import requests
from urllib.parse import quote

BASE = "https://openrouter.ai"
LIST_MODELS_URL = f"{BASE}/api/v1/models"

# ---- inputs (example) ----
SUBSTRINGS = [
    "Gemini 2.5",
    "Sonnet 4",
    "Opus 4",
    "Kimi K2",
    "Deepseek R1",
]

# ---- data structures ----
@dataclass(frozen=True)
class ModelHit:
    name: str
    model_id: str
    canonical_slug: str

    @property
    def url(self) -> str:
        # Build website URL from canonical_slug.
        # Encode the path segment after the first '/' to be safe if a ':' ever appears.
        author, slug = self.canonical_slug.split("/", 1)
        return f"{BASE}/{author}/{quote(slug, safe='')}"


@dataclass(frozen=True)
class ProviderRow:
    model_name: str
    model_url: str
    model_id: str
    provider: str
    context_length: int | None
    price_input_token: str | None
    price_output_token: str | None
    latency: float | None           # not currently available via API
    throughput: float | None        # not currently available via API


# ---- helpers ----
def _fetch_json(url: str) -> Dict[str, Any]:
    r = requests.get(url, timeout=30)
    r.raise_for_status()
    return r.json()

def _list_models() -> List[Dict[str, Any]]:
    return _fetch_json(LIST_MODELS_URL)["data"]

def _is_free(model: Dict[str, Any]) -> bool:
    name = (model.get("name") or "").lower()
    mid = (model.get("id") or "").lower()
    return ":free" in mid or "(free" in name

def _name_matches(name: str, needles: Iterable[str]) -> bool:
    l = name.lower()
    return any(n.lower() in l for n in needles)

def _list_endpoints(canonical_slug: str) -> List[Dict[str, Any]]:
    # API path uses author/slug as-is (colons allowed if present).
    url = f"{BASE}/api/v1/models/{canonical_slug}/endpoints"
    return _fetch_json(url)["data"]["endpoints"]

# ---- main API ----
def find_models_by_name_parts(parts: Iterable[str]) -> List[ModelHit]:
    hits: List[ModelHit] = []
    for m in _list_models():
        if _is_free(m):
            continue
        if not _name_matches(m.get("name", ""), parts):
            continue
        slug = m.get("canonical_slug") or m["id"].split(":")[0]
        hits.append(ModelHit(name=m["name"], model_id=m["id"], canonical_slug=slug))
    # optional: de‑dupe by model_id
    seen = set()
    unique = []
    for h in hits:
        if h.model_id in seen:
            continue
        seen.add(h.model_id)
        unique.append(h)
    return unique

def expand_providers(models: Iterable[ModelHit]) -> List[ProviderRow]:
    rows: List[ProviderRow] = []

    def work(h: ModelHit) -> List[ProviderRow]:
        out: List[ProviderRow] = []
        for ep in _list_endpoints(h.canonical_slug):
            pricing = ep.get("pricing", {}) or {}
            # context length can be either 'context_length' or 'max_prompt_tokens'
            ctx = ep.get("context_length") or ep.get("max_prompt_tokens")
            out.append(ProviderRow(
                model_name=h.name,
                model_url=h.url,
                model_id=h.model_id,
                provider=ep.get("provider_name"),
                context_length=int(ctx) if isinstance(ctx, (int, float)) else (int(ctx) if isinstance(ctx, str) and ctx.isdigit() else None),
                price_input_token=pricing.get("prompt"),
                price_output_token=pricing.get("completion"),
                # These are not in the documented API as of 2025‑07‑26; leave None.
                latency=ep.get("latency") if "latency" in ep else None,
                throughput=ep.get("throughput") if "throughput" in ep else None,
            ))
        return out

    with cf.ThreadPoolExecutor(max_workers=8) as pool:
        for batch in pool.map(work, models):
            rows.extend(batch)
    return rows


if __name__ == "__main__":
    models = find_models_by_name_parts(SUBSTRINGS)
    rows = expand_providers(models)

    # Print a compact report
    from textwrap import shorten
    print(f"Found {len(models)} matching models; emitting {len(rows)} provider rows.\n")
    for r in rows:
        print(
            f"{shorten(r.model_name, 60)} | {r.provider:>12} | ctx={r.context_length} | "
            f"in={r.price_input_token} | out={r.price_output_token} | "
            f"lat={r.latency} | tps={r.throughput} | {r.model_url}"
        )

    # Optional: write CSV
    # import csv
    # with open("openrouter_models_providers.csv", "w", newline="", encoding="utf-8") as f:
    #     w = csv.writer(f)
    #     w.writerow(["Model name","Model URL","OpenRouter model ID","Provider","Context length",
    #                 "Price/input token","Price/output token","Latency","Throughput"])
    #     for r in rows:
    #         w.writerow([r.model_name, r.model_url, r.model_id, r.provider, r.context_length,
    #                     r.price_input_token, r.price_output_token, r.latency, r.throughput])
Notes / behavior guarantees
Model URL construction. Uses canonical_slug from /api/v1/models and forms https://openrouter.ai/{canonical_slug}. 
OpenRouter

Provider details. Pulled from /api/v1/models/:author/:slug/endpoints (per‑provider context_length, pricing.prompt, pricing.completion, provider_name). 
OpenRouter

Excluding free variants. Filters anything whose id contains :free or whose name includes “(free”. Example slug format on the site: deepseek/deepseek-r1%3Afree. 
OpenRouter

Latency / Throughput. These metrics are shown on the model webpages and discussed in docs (sorting by throughput via :nitro/provider.sort), but they are not in the documented endpoints response as of 2025‑07‑26; hence the code fills None. If OpenRouter adds them later, the fields will be picked up automatically via the ep.get(...) reads.